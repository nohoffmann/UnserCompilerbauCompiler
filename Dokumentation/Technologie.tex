% !TEX root = Main.tex

\section{Verwendete Technologien}

\subsection{Eclipse}
Zur Entwicklung wurde die integrierte Entwicklungsumgebung Eclipse in der aktuellen Version (4.8.0) genutzt. 
Eclipse bietet mehrere Vorteile, die ein einfacheres und effizienteres Entwickeln erlauben. Eclipse enthält einen Datei-Explorer, mit dessen Hilfe die Navigation durch die verschiedenen Verzeichnisse zusammen mit Editor und Konsole innerhalb eines Fensters geschehen kann. Des Weiteren bietet Eclipse automatische Vorschläge zur Code- und Textvervollständigung an, was die Schreibgeschwindigkeit und damit die Arbeitseffizienz erhöht. 
Außerdem kann Eclipse durch Plug-Ins erweitert werden. Als Plug-In nutzen wir beispielsweise das Test-Framework TestNG, um verschiedene Testfälle automatisiert zu prüfen.
\\\\
Ein großer Nachteil von Eclipse ist die von uns erfahrene Unzuverlässigkeit. Die IDE gibt immer wieder nicht nachvollziehbare, manchmal sogar gar keine Fehlermeldungen aus, wenn Aufgaben wie das Öffnen und Kompilieren von Projekten fehlschlagen. Des Weiteren trat unabhängig voneinander auf verschiedenen Rechnern mit verschiedenen Betriebssystemen (getestet u.A. unter Ubuntu, Arch (jeweils Linux-Distributionen) und Mac OS X) das Problem auf, dass das Projekt nicht geöffnet werden konnte. Besonders seltsam war jedoch die Situation, dass sich das Projekt mit der \textit{'Eclipse IDE for C/C++ Developers'} öffnen ließ, nicht jedoch mit \textit{'Eclipse IDE for Java Developers'}. Letztendlich war die Arbeit mit Eclipse unter Arch Linux nicht möglich, sodass andere Projektteilnehmer die Aufgabe des Kompilierens übernehmen mussten.

\subsection{TestNG}
% TO-DO: Versionsnummer prüfen
TestNG ist ein Framework, das dem zu testenden Programm Eingabewerte übergibt und die tatsächlichen Ergebnisse des Programms mit den erwarteten Ergebnissen abgleicht. Dabei können beliebig viele Testszenarien geprüft werden. Es werden sogenannte positive Tests, also solche, bei denen die Eingabe ein erwartetes Ergebnis hervorruft, als auch negative Tests, bei denen geprüft wird, ob nicht vorhergesehene Eingaben mit entsprechenden Fehlermeldungen korrekt behandelt werden, durchgeführt. TestNG wurde von uns in Version 6.14 genutzt.

\pagebreak
Als Beispiel: Der Quelltext
\begin{lstlisting} [frame=single]
println(1+4);
\end{lstlisting}

sollte als Ergebnis ''5'' auf der Konsole ausgeben. TestNG übergibt den Quelltext an unseren Compiler, ruft Jasmin auf, führt das Programm aus und gleicht dann die Ergebnisse ab. Wenn das Ergebnis ''5'' ist, gilt der Test als bestanden, andernfalls als durchgefallen. 

\subsection{ANTLR}
ANTLR steht für \textit{ANother Tool for Language Recognition} und ist ein Lexer- und Parsergenerator. ANTLR generiert auf Grundlage einer Grammatik-Datei Java-Code, der einen entsprechenden Lexer sowie ein Template für Teile des Parsers implementiert. Dadurch, dass die von ANTLR generierten Programme aus einer Eingabedatei in der Ausgangssprache einen Syntaxbaum erstellen können, besteht der größte Arbeitsaufwand daraus, Grammatiken für ANTLR zu formulieren und Teile des Parsers (in unserem Fall einen Visitor) zu implementieren. Es wurde die ANTLR-Version 4.7.1 verwendet.

\subsection{Jasmin}
Jasmin ist ein Assembler für die Java Virtual Machine. Dabei werden Textdateien mit Anweisungen in Jasmin-Syntax zu Bytecode übersetzt. Dieser Bytecode kann von der JVM ausgeführt werden.

\subsection{Java}
Die Programmiersprache Java wurde für das Projekt gewählt, da der von ANTLR generierte Code ebenfalls in Java erstellt wird. Es ist teilweise notwendig von Klassen des von ANTLR generierten Code abzuleiten, weshalb die Wahl einer anderen Programmiersprache als Java Problemstellungen wie die Code-Kompatibilität und Portabilität dargestellt hätte. 
Des Weiteren muss die Java Runtime Environment ohnehin genutzt werden, um ANTLR, Jasmin sowie schließlich die Kompilate des Compilers auszuführen.

\subsection{Java Virtual Machine}
Die Java VM ist ein Zwischenschritt beim Ausführen von Java-Code. Eine Java-Quelldatei (.java) wird zunächst durch den Java-Compiler zu Bytecode (.class) übersetzt und dann von der Java VM interpretiert. Dieser Zwischenschritt ermöglicht eine Plattformunabhängigkeit, da die Kompilate (.class-Dateien) nicht maschinenspezifisch übersetzt werden. Plattformabhängiger Code wird erst von der Java VM ausgeführt, wenn diese den Bytecode interpretiert, weshalb der Bytecode für jeden Computer maschinenunanbhängig generiert und ausgeführt werden kann, solange für die entsprechende Maschine die Java VM verfügbar ist.

In diesem Projekt wird die Java VM verwendet, um die Kompilate unseres eigenen Compilers, nachdem diese von Jasmin bearbeitet wurden, auszuführen.

Zu beachten ist, dass die Java VM stack-basiert operiert und nicht wie der x86-Befehlssatz mit Registern arbeitet. Dies ist bei der Implementierung des Compilers zu beachten und erfordert eine besondere Denkweise.
% @Noah: Genauer beschreiben

\subsection{Git}
Nach einiger Zeit der Arbeit am Projekt wurde klar, dass es auf Dauer sehr ineffizient ist, die Aktualisierungen über eine WhatsApp-Gruppe zu verteilen. Daher haben wir über die Plattform \textit{GitHub} ein Repository erstellt, in dem alle Änderungen zentral verwaltet und verteilt werden.