% !TEX root = Main.tex

\section{Verwendete Technologien}

\subsection{Eclipse}
Zur Entwicklung wurde die integrierte Entwicklungsumgebung Eclipse in der aktuellen Version (4.8.0) genutzt. 
Eclipse bietet mehrere Vorteile, die ein einfacheres und effizienteres Entwickeln erlauben. Eclipse enthält einen Datei-Explorer, mit dessen Hilfe die Navigation durch die verschiedenen Verzeichnisse zusammen mit Editor und Konsole innerhalb eines Fensters geschehen kann. Des Weiteren bietet Eclipse automatische Vorschläge zur Code- und Textvervollständigung an, was die Schreibgeschwindigkeit und damit die Arbeitseffizienz erhöht. 
Außerdem kann Eclipse durch Plug-Ins erweitert werden. Als Plug-In nutzen wir beispielsweise das Test-Framework TestNG, um verschiedene Testfälle automatisiert zu prüfen.
\\\\
Ein großer Nachteil von Eclipse ist die Unzuverlässigkeit. Die IDE gibt oft nicht nachvollziehbare, manchmal sogar gar keine Fehlermeldungen aus. Desweiteren trat unabhängig voneinander auf verschiedenen Rechnern mit verschiedenen Betriebssystemen (getestet u.A. unter Ubuntu Linux, Arch Linux und Mac OS X) das Problem auf, dass das Projekt nicht geöffnet werden konnte. Besonders kafkaesk war jedoch die Situation, dass sich das Projekt mit der \textit{'Eclipse IDE for C/C++ Developers'} öffnen ließ. Letzendlich war die Arbeit mit Eclipse unter Arch Linux nicht möglich, sodass andere Projektteilnehmer die Aufgabe des Kompilierens übernehmen mussten.

\subsection{TestNG}
% TO-DO: Versionsnummer prüfen
TestNG ist ein Framework, das dem zu testenden Programm Eingabewerte übergibt und die tatsächlichen Ergebnisse des Programms mit den erwarteten Ergebnissen abgleicht. Dabei können beliebig viele Testszenarien geprüft werden. Es werdeLetzendlich war die Arbeit mit Eclipse unter Arch Linux nicht möglich, sodass andere Projektteilnehmer die Aufgabe des n sogenannte positive Tests, also solche, bei denen die Eingabe ein erwartetes Ergebnis hervorruft, als auch negative Tests, bei denen geprüft wird, ob nicht vorhergesehene Eingaben mit entsprechenden Fehlermeldungen korrekt behandelt werden, durchgeführt. TestNG wurde von uns in Version 6.10 (PRÜFEN!) genutzt.

Als Beispiel: Der Quelltext
\begin{lstlisting} [frame=single]
println(1+4);
\end{lstlisting}

sollte als Ergebnis ''5'' auf der Konsole ausgeben. TestNG übergibt den Quelltext an unseren Compiler, ruft Jasmin auf, führt das Programm aus und gleicht dann die Ergebnisse ab. Wenn das Ergebnis ''5'' ist, gilt der Test als bestanden, andernfalls als durchgefallen. 

\subsection{ANTLR}
ANTLR steht für \textit{ANother Tool for Language Recognition} und ist ein Lexer- und Parsergenerator. ANTLR generiert auf Grundlage einer Grammatik-Datei Java-Code, der einen entsprechenden Lexer sowie ein Template für Teile des Parsers implementiert. Dadurch, dass die von ANTLR generierten Programme aus einer Eingabedatei in der Ausgangssprache einen Syntaxbaum erstellen können, besteht der größte Arbeitsaufwand daraus, Grammatiken für ANTLR zu formulieren und Teile des Parsers (in unserem Fall ein Visitor) zu implementieren. Es wurde die ANTLR-Version 4.7.1 verwendet.

\subsection{Jasmin}
Jasmin ist ein Assembler für die Java Virtual Machine. Dabei werden Textdateien mit Anweisungen in Jasmin-Syntax zu Bytecode übersetzt. Dieser Bytecode kann von der JVM ausgeführt werden.

\subsection{Java}
% TO-DO: Finalen Namen der Sprache einfügen
Die Programmiersprache Java wurde für das Projekt gewählt, da der von ANTLR generierte Code ebenfalls in Java ist. Es ist teilweise notwendig von Klassen des ANTLR generierten Code abzuleiten, weshalb die Wahl einer anderen Programmiersprache als Java Problemstellungen wie die Code-Kompatibilität zur anderen Programmiersprache darstellt. 
Des Weiteren muss die Java Runtime Environment ohnehin genutzt werden, um ANTLR, Jasmin sowie schließlich die Kompilate des C=-Compilers auszuführen.

\subsection{Java Virtual Machine}
Die Java VM ist ein Zwischenschritt beim Ausführen von Java-Code. Eine Java-Quelldatei (.java) wird zunächst durch den Java-Compiler zu Bytecode (.class) übersetzt und dann von der Java VM interpretiert. Dieser Zwischenschritt ermöglicht eine Plattformunabhängigkeit, da die Kompilate (.class-Dateien) nicht maschinenspezifisch übersetzt werden. Plattformabhängiger Maschinencode wird erst von der Java VM generiert, weshalb jeder Bytecode ausgeführt werden kann, solange für die entsprechende Maschine die Java VM verfügbar ist.
% ToDo : Java generiert keinen Maschinenspezifischen Bytecode: JavaVM liest den Maschinenunabhängigen Bytecode Byte für Byte aus und kann dann evtl. Maschinenabhängig interpretieren. Ist Quasi ab hier wie eine Interpretersprache. Interpreter bekommt maschinenunabhängigen Code und weiss dann, wie er auf der Maschine auszuführen ist, dass das Ergebnis gleich bleibt.

In diesem Projekt wird die Java VM jedoch nicht nur zur Übersetzung unseres Code genutzt, sondern auch um die Kompilate unseres eigenen Compilers auszuführen. Diese Kompilate werden von Jasmin zu Bytecode übersetzt, der Bytecode wiederum wird von der Java VM ausgeführt.

% ToDo : Doppelt????

Zu beachten ist, dass die Java VM stack-basiert operiert und nicht wie beispielsweise der x86-Befehlssatz mit Registern arbeitet, was bei der Implementierung zu beachten ist und eine besondere Denkweise erfordert. 

\subsection{Git}
Nach einiger Zeit der Arbeit am Projekt wurde klar, dass es auf Dauer sehr ineffizient ist, die Aktualisierungen über eine WhatsApp-Gruppe zu verteilen. Daher haben wir über die Plattform \textit{GitHub} ein Repository erstellt. Die Arbeit über das Webinterface auf github.com sowie mit der 'GitHub Desktop'-App lief störungsfrei.